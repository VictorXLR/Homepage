<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Mirage</title>
        <style>
            body,
            html {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background-color: #000;
                overflow: hidden;
            }
            canvas {
                display: block;
                width: 100vw;
                height: 100vh;
            }
        </style>
    </head>
    <body>
        <canvas id="glcanvas"></canvas>

        <script id="vertex-shader" type="x-shader/x-vertex">
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        </script>

        <script id="fragment-shader" type="x-shader/x-fragment">
            #ifdef GL_ES
            precision highp float;
            #endif

            uniform float time;
            uniform vec2 resolution;

            mat2 rot(float th){
                return mat2(cos(th),sin(th),-sin(th),cos(th));
            }

            void mainImage( out vec4 fragColor, in vec2 fragCoord )
            {
                const int n_iter=8;
                float s=0.;
                for(int k=0;k<n_iter;k++){
                    float t = time + 0.0001 * float(k);
                    float th = 0.1*t;
                    float a = 0.4+0.3*mod(floor(t*0.1/6.2832), 3.0);    
                    vec2 p = (2.0 * fragCoord - resolution.xy) / min(resolution.x, resolution.y);
                    for (int i=0;i<50;++i){
                        p.x += a * abs(p.y) - 0.3;
                        p *= rot(th);
                    }
                    s += step(p.y,0.0);
                }
                s /= float(n_iter);
                fragColor = vec4(vec3(s),1);
            }

            void main(void)
            {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        </script>

        <script>
            const canvas = document.getElementById("glcanvas");
            const gl = canvas.getContext("webgl");

            if (!gl) {
                alert(
                    "WebGL not supported, but it is required for this effect.",
                );
            }

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            window.addEventListener("resize", resize);
            resize();

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createProgram(gl, vertexSource, fragmentSource) {
                const vertexShader = createShader(
                    gl,
                    gl.VERTEX_SHADER,
                    vertexSource,
                );
                const fragmentShader = createShader(
                    gl,
                    gl.FRAGMENT_SHADER,
                    fragmentSource,
                );
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error(gl.getProgramInfoLog(program));
                    return null;
                }
                return program;
            }

            const vsSource = document.getElementById("vertex-shader").text;
            const fsSource = document.getElementById("fragment-shader").text;
            const program = createProgram(gl, vsSource, fsSource);

            const positionAttributeLocation = gl.getAttribLocation(
                program,
                "a_position",
            );
            const resolutionUniformLocation = gl.getUniformLocation(
                program,
                "resolution",
            );
            const timeUniformLocation = gl.getUniformLocation(
                program,
                "time",
            );

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, -1, -1, 3, 3, -1];
            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array(positions),
                gl.STATIC_DRAW,
            );

            function render(time) {
                time *= 0.001;

                gl.useProgram(program);

                gl.enableVertexAttribArray(positionAttributeLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(
                    positionAttributeLocation,
                    2,
                    gl.FLOAT,
                    false,
                    0,
                    0,
                );

                gl.uniform2f(
                    resolutionUniformLocation,
                    canvas.width,
                    canvas.height,
                );
                gl.uniform1f(timeUniformLocation, time);

                gl.drawArrays(gl.TRIANGLES, 0, 3);

                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        </script>
    </body>
</html>
