<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Kirby</title>
        <style>
            body,
            html {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background-color: #000;
                overflow: hidden;
            }
            canvas {
                display: block;
                width: 100vw;
                height: 100vh;
            }
        </style>
    </head>
    <body>
        <canvas id="glcanvas"></canvas>

        <script id="vertex-shader" type="x-shader/x-vertex">
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        </script>

        <script id="fragment-shader" type="x-shader/x-fragment">
            #ifdef GL_ES
            precision mediump float;
            #endif

            uniform float time;
            uniform vec2 resolution;

            vec3  iResolution;
            float iTime;

            float smin( float a, float b, float k )
            {
                float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
                return mix( b, a, h ) - k*h*(1.0-h);
            }

            float sdCapsule( vec3 p, vec3 a, vec3 b, float r )
            {
                vec3 pa = p-a, ba = b-a;
                float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
                return length( pa - ba*h ) - r;
            }


            float smax(float a,float b, float k)
            {
                return -smin(-a,-b,k);
            }

            mat2 rotmat(float a)
            {
                return mat2(cos(a),sin(a),-sin(a),cos(a));
            }

            float shoesDist(vec3 p)
            {
                vec3 op=p;
                float d=1e4;

                p.y-=1.5;

                op=p;
                p-=vec3(-.5,-.6,-.9);
                p.yz=rotmat(-.7)*p.yz;
                p.xz=rotmat(0.1)*p.xz;
                d=min(d,-smin(p.y,-(length(p*vec3(1.6,1,1))-.64),.2));
                p=op;

                op=p;
                p-=vec3(.55,-.8,0.4);
                p.x=-p.x;
                p.yz=rotmat(1.4)*p.yz;
                d=min(d,-smin(p.y,-(length(p*vec3(1.6,1,1))-.73),.2));
                p=op;
                return d;
            }

            float sceneDist(vec3 p)
            {
                vec3 op=p;
                float d=shoesDist(p);

                d=min(d,p.y);
                p.y-=1.5;

                d=min(d,length(p)-1.);

                op=p;
                p-=vec3(.66,.7,0);
                p.xz=rotmat(-0.1)*p.xz;
                d=smin(d,(length(p*vec3(1.8,1,1))-.58),.07);
                p=op;

                op=p;
                p-=vec3(-.75,0.2,0);
                d=smin(d,(length(p*vec3(1,1.5,1))-.54),.03);
                p=op;

                p.y-=.11;
                float md=smax(p.z+.84,smax(smax(p.x-.2,p.y-.075,.2),dot(p,vec3(.7071,-.7071,0))-.1,.08),.04);
                p.x=-p.x;
                md=smax(md,smax(p.z+.84,smax(smax(p.x-.2,p.y-.075,.2),dot(p,vec3(.7071,-.7071,0))-.1,.08),.01),.13);
                d=smax(d,-md,.012);

                p=op;
                d=smin(d,length((p-vec3(0,.03,-.75))*vec3(1,1,1))-.16,.01);

                return min(d,10.);
            }



            vec3 sceneNorm(vec3 p)
            {
                vec3 e=vec3(1e-3,0,0);
                float d = sceneDist(p);
                return normalize(vec3(sceneDist(p + e.xyy) - sceneDist(p - e.xyy), sceneDist(p + e.yxy) - sceneDist(p - e.yxy),
                              sceneDist(p + e.yyx) - sceneDist(p - e.yyx)));
            }


            float ambientOcclusion(vec3 p, vec3 n)
            {
                const int steps = 4;
                const float delta = 0.15;

                float a = 0.0;
                float weight = 4.;
                for(int i=1; i<=steps; i++) {
                    float d = (float(i) / float(steps)) * delta; 
                    a += weight*(d - sceneDist(p + n*d));
                    weight *= 0.5;
                }
                return clamp(1.0 - a, 0.0, 1.0);
            }

            float cos2(float x){return cos(x-sin(x)/3.);}

            float starShape(vec2 p)
            {
                float a=atan(p.y,p.x)+iTime/3.;
                float l=pow(length(p),.8);
                float star=1.-smoothstep(0.,(3.-cos2(a*5.*2.))*.02,l-.5+cos2(a*5.)*.1);
                return star;
            }


            void mainImage( out vec4 fragColor, in vec2 fragCoord )
            {
                vec2 uv = fragCoord/iResolution.xy;

                float an=cos(iTime)*.1;

                vec2 ot=uv*2.-1.;
                ot.y*=iResolution.y/iResolution.x;
                vec3 ro=vec3(0.,1.4,4.);
                vec3 rd=normalize(vec3(ot.xy,-1.3));

                rd.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xz;
                ro.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xz;

                float s=20.;

                float t=0.,d=0.;
                for(int i=0;i<80;++i)
                {
                    d=sceneDist(ro+rd*t);
                    if(d<1e-4)
                        break;
                    if(t>10.)
                        break;
                    t+=d*.9;
                }

                t=min(t,10.0);

                vec3 rp=ro+rd*t;
                vec3 n=sceneNorm(rp);
                float st=5e-3;
                vec3 ld=normalize(vec3(2,4,-4));
                for(int i=0;i<20;++i)
                {
                    d=sceneDist(rp+ld*st);
                    if(d<1e-5)
                        break;
                    if(st>5.)
                        break;
                    st+=d*2.;
                }

                vec3 ao=vec3(ambientOcclusion(rp, n));
                float shad=mix(.85,1.,step(5.,st));

                ao*=mix(.3,1.,.5+.5*n.y);

                if(rp.y<1e-3)
                    ao*=mix(mix(vec3(1,.5,.7),vec3(1),.4)*.6,vec3(1),smoothstep(0.,1.6,length(rp.xz)));



                vec3 diff=vec3(1);
                vec3 emit=vec3(0);

                diff*=vec3(1.15,.3,.41)*1.4;
                diff+=.4*mix(1.,0.,smoothstep(0.,1.,length(rp.xy-vec2(0.,1.9))));
                diff+=.5*mix(1.,0.,smoothstep(0.,.5,length(rp.xy-vec2(.7,2.5))));
                diff+=.36*mix(1.,0.,smoothstep(0.,.5,length(rp.xy-vec2(-1.1,1.8))));

                if(rp.y<1e-3)
                    diff=vec3(.6,1,.6);

                diff*=mix(vec3(1,.3,.2),vec3(1),smoothstep(.97,.99,length(rp-vec3(0,1.5,0))));

                diff=mix(vec3(1.,.05,.1),diff,smoothstep(0.,0.01,shoesDist(rp)));
                diff+=.2*mix(1.,0.,smoothstep(0.,.2,length(rp.xy-vec2(-0.5,1.4))));
                diff+=.12*mix(1.,0.,smoothstep(0.,.25,length(rp.xy-vec2(0.57,.3))));

                diff+=vec3(.25,1.,.25)*smoothstep(-.3,1.7,-rp.y+1.)*max(0.,-n.y)*.7;

                vec3 orp=rp;
                rp.y-=1.5;
                rp.x=abs(rp.x);

                diff*=mix(vec3(1,.5,.5),vec3(1),smoothstep(.1,.15,length((rp.xy-vec2(.4,.2))*vec2(1,1.65))));

                rp.xy-=vec2(.16,.45);
                rp.xy*=.9;
                orp=rp;
                rp.y=pow(abs(rp.y),1.4)*sign(rp.y);

                diff*=smoothstep(.058,.067,length((rp.xy)*vec2(.9,.52)));

                rp=orp;
                rp.y+=.08;
                rp.y-=pow(abs(rp.x),2.)*16.;

                emit+=vec3(.1,.5,1.)*(1.-smoothstep(.03,.036,length((rp.xy)*vec2(.7,.3))))*max(0.,-rp.y)*10.;

                rp=orp;
                rp.y-=.12;

                emit+=vec3(1)*(1.-smoothstep(.03,.04,length((rp.xy)*vec2(1.,.48))));

                diff+=pow(clamp(1.-dot(-rd,n),0.,.9),4.)*.5;

                vec3 backg=vec3(1.15,.3,.41)*.9;
                ot.x+=.6+iTime/50.;
                ot.y+=cos(floor(ot.x*2.)*3.)*.1+.2;
                ot.x=mod(ot.x,.5)-.25;
                backg=mix(backg,vec3(1.,1.,.5),.1*starShape((ot-vec2(0.,.6))*8.)*smoothstep(9.,10.,t));
                diff=mix(diff,backg,smoothstep(.9,10.,t));

                fragColor.rgb=mix(vec3(.15,0,0),vec3(1),ao)*shad*diff*1.1;
                fragColor.rgb+=emit;

                fragColor.rgb=pow(fragColor.rgb,vec3(1./2.4));
                fragColor.a=1.0;
            }

            void main(void)
            {
                iResolution = vec3(resolution, 0.0);
                iTime = time;

                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        </script>

        <script>
            const canvas = document.getElementById("glcanvas");
            const gl = canvas.getContext("webgl");

            if (!gl) {
                alert(
                    "WebGL not supported, but it is required for this effect.",
                );
            }

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            window.addEventListener("resize", resize);
            resize();

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createProgram(gl, vertexSource, fragmentSource) {
                const vertexShader = createShader(
                    gl,
                    gl.VERTEX_SHADER,
                    vertexSource,
                );
                const fragmentShader = createShader(
                    gl,
                    gl.FRAGMENT_SHADER,
                    fragmentSource,
                );
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error(gl.getProgramInfoLog(program));
                    return null;
                }
                return program;
            }

            const vsSource = document.getElementById("vertex-shader").text;
            const fsSource = document.getElementById("fragment-shader").text;
            const program = createProgram(gl, vsSource, fsSource);

            const positionAttributeLocation = gl.getAttribLocation(
                program,
                "a_position",
            );
            const resolutionUniformLocation = gl.getUniformLocation(
                program,
                "resolution",
            );
            const timeUniformLocation = gl.getUniformLocation(
                program,
                "time",
            );

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, -1, -1, 3, 3, -1];
            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array(positions),
                gl.STATIC_DRAW,
            );

            function render(time) {
                time *= 0.001;

                gl.useProgram(program);

                gl.enableVertexAttribArray(positionAttributeLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(
                    positionAttributeLocation,
                    2,
                    gl.FLOAT,
                    false,
                    0,
                    0,
                );

                gl.uniform2f(
                    resolutionUniformLocation,
                    canvas.width,
                    canvas.height,
                );
                gl.uniform1f(timeUniformLocation, time);

                gl.drawArrays(gl.TRIANGLES, 0, 3);

                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        </script>
    </body>
</html>
